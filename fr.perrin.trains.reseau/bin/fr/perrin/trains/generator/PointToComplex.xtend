/*
 * generated by Xtext 2.20.0
 */
package fr.perrin.trains.generator

import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import fr.perrin.trains.simulator.Complex
import fr.perrin.trains.reseau.DeclarationPoint
import fr.perrin.trains.reseau.CoordonneeLiteral
import fr.perrin.trains.reseau.NumberLiteral
import fr.perrin.trains.reseau.Negative
import fr.perrin.trains.reseau.Plus
import fr.perrin.trains.reseau.Minus
import fr.perrin.trains.reseau.Div
import fr.perrin.trains.reseau.Multi
import fr.perrin.trains.reseau.Degree
import fr.perrin.trains.reseau.Pow
import fr.perrin.trains.reseau.Nord
import fr.perrin.trains.reseau.Sud
import fr.perrin.trains.reseau.Est
import fr.perrin.trains.reseau.Ouest
import fr.perrin.trains.reseau.I
import fr.perrin.trains.reseau.Pi
import fr.perrin.trains.reseau.Euler
import fr.perrin.trains.reseau.Declared
import fr.perrin.trains.reseau.X
import fr.perrin.trains.reseau.Y
import fr.perrin.trains.reseau.Longueur
import fr.perrin.trains.reseau.Angle
import fr.perrin.trains.reseau.Argument
import fr.perrin.trains.reseau.Point

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PointToComplex {

	HashMap<String, Complex> values

	def initialize (Resource resource) {
		values = new HashMap<String, Complex>()
		for(DeclarationPoint decl :  resource.allContents.toIterable.filter(DeclarationPoint)) {
			values.put(decl.name,evaluate(decl.xy));
		}
	}

	def Complex evaluate(Point obj) {
		return internalEvaluate(obj)
	}

	def dispatch protected Complex internalEvaluate(CoordonneeLiteral c) {
		val left = evaluate(c.left)
		val right = evaluate(c.right)
		return new Complex(left.x - right.y, left.y + right.x)
	}

	def dispatch protected Complex internalEvaluate(NumberLiteral n) {
		return new Complex(n.value,0);
	}

	def dispatch protected Complex internalEvaluate(Negative p) {
		val value = evaluate(p.value)
		return new Complex(-value.x, -value.y);
	}

	def dispatch protected Complex internalEvaluate(Plus plus) {
		return Complex.sum(evaluate(plus.left), evaluate(plus.right))
	}

	def dispatch protected Complex internalEvaluate(Minus minus) {
		return Complex.sub(evaluate(minus.left), evaluate(minus.right))
	}

	def dispatch protected Complex internalEvaluate(Div div) {
		return Complex.div(evaluate(div.left), evaluate(div.right))
	}

	def dispatch protected Complex internalEvaluate(Multi multi) {
		return Complex.mult(evaluate(multi.left), evaluate(multi.right))
	}

	def dispatch protected Complex internalEvaluate(Degree degre) {
		return new Complex(Math.cos(Math.PI * evaluate(degre.left).x/180), Math.sin(Math.PI * evaluate(degre.left).x/180))
	}
	
	def dispatch protected Complex internalEvaluate(Pow pow) {
		return Complex.pow(evaluate(pow.left), evaluate(pow.right))
	}

	def dispatch protected Complex internalEvaluate(Nord n) {
		return new Complex(0,1);
	}
	def dispatch protected Complex internalEvaluate(Sud s) {
		return new Complex(0,-1);
	}
	def dispatch protected Complex internalEvaluate(Est e) {
		return new Complex(1,0);
	}
	def dispatch protected Complex internalEvaluate(Ouest o) {
		return new Complex(-1,0);
	}
	def dispatch protected Complex internalEvaluate(I i) {
		return new Complex(0,1);
	}
	def dispatch protected Complex internalEvaluate(Pi pi) {
		return new Complex(Math.PI,0);
	}
	def dispatch protected Complex internalEvaluate(Euler e) {
		return new Complex(Math.E,0);
	}

	def dispatch protected Complex internalEvaluate(Declared d) {
		if(values.containsKey(d.decl.name)) {
			return values.get(d.decl.name);
		} else {
			return new Complex(0,0);
		}
	}

	def dispatch protected Complex internalEvaluate(X p) {
		return new Complex(evaluate(p.value).x, 0);
	}

	def dispatch protected Complex internalEvaluate(Y p) {
		return new Complex(evaluate(p.value).y, 0);
	}

	def dispatch protected Complex internalEvaluate(Longueur p) {
		return new Complex(evaluate(p.value).longueur, 0);
	}

	def dispatch protected Complex internalEvaluate(Angle p) {
		return new Complex(180*evaluate(p.value).angle / Math.PI, 0);
	}

	def dispatch protected Complex internalEvaluate(Argument p) {
		return new Complex(evaluate(p.value).angle, 0);
	}

	def printNew (Complex c) '''new Complex(«c.x», «c.y»)'''


}
